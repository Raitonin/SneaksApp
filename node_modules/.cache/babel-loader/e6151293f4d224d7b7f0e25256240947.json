{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PromisableRequest = void 0;\n\nconst events_1 = require(\"events\");\n\nconst PCancelable = require(\"p-cancelable\");\n\nconst calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\n\nconst types_1 = require(\"./types\");\n\nconst core_1 = require(\"./core\");\n\nexports.PromisableRequest = core_1.default;\n\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\n\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\n\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\n\nfunction asPromise(options) {\n  let retryCount = 0;\n  let globalRequest;\n  let globalResponse;\n  const emitter = new events_1.EventEmitter();\n  const promise = new PCancelable((resolve, _reject, onCancel) => {\n    const makeRequest = () => {\n      // Support retries\n      // `options.throwHttpErrors` needs to be always true,\n      // so the HTTP errors are caught and the request is retried.\n      // The error is **eventually** thrown if the user value is true.\n      const {\n        throwHttpErrors\n      } = options;\n\n      if (!throwHttpErrors) {\n        options.throwHttpErrors = true;\n      } // Note from @szmarczak: I think we should use `request.options` instead of the local options\n\n\n      const request = new core_1.default(options.url, options);\n      request._noPipe = true;\n      onCancel(() => request.destroy());\n\n      const reject = error => {\n        void (async () => {\n          try {\n            for (const hook of options.hooks.beforeError) {\n              // eslint-disable-next-line no-await-in-loop\n              error = await hook(error);\n            }\n          } catch (error_) {\n            _reject(new types_1.RequestError(error_.message, error_, request));\n\n            return;\n          }\n\n          _reject(error);\n        })();\n      };\n\n      globalRequest = request;\n\n      const onResponse = async response => {\n        var _a;\n\n        response.retryCount = retryCount;\n\n        if (response.request.aborted) {\n          // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n          return;\n        }\n\n        const isOk = () => {\n          const {\n            statusCode\n          } = response;\n          const limitStatusCode = options.followRedirect ? 299 : 399;\n          return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;\n        }; // Download body\n\n\n        let rawBody;\n\n        try {\n          rawBody = await get_buffer_1.default(request);\n          response.rawBody = rawBody;\n        } catch (_b) {\n          // The same error is caught below.\n          // See request.once('error')\n          return;\n        } // Parse body\n\n\n        const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n        const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n\n        if (isCompressed && !options.decompress) {\n          response.body = rawBody;\n        } else {\n          try {\n            response.body = core_1.parseBody(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fallback to `utf8`\n            response.body = rawBody.toString();\n\n            if (isOk()) {\n              // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995\n              reject(error);\n              return;\n            }\n          }\n        }\n\n        try {\n          for (const [index, hook] of options.hooks.afterResponse.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              const typedOptions = core_1.default.normalizeArguments(undefined, { ...updatedOptions,\n                retry: {\n                  calculateDelay: () => 0\n                },\n                throwHttpErrors: false,\n                resolveBodyOnly: false\n              }, options); // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n\n              typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n\n              for (const hook of typedOptions.hooks.beforeRetry) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(typedOptions);\n              }\n\n              const promise = asPromise(typedOptions);\n              onCancel(() => {\n                promise.catch(() => {});\n                promise.cancel();\n              });\n              return promise;\n            });\n          }\n        } catch (error) {\n          // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995\n          reject(new types_1.RequestError(error.message, error, request));\n          return;\n        }\n\n        if (throwHttpErrors && !isOk()) {\n          reject(new types_1.HTTPError(response));\n          return;\n        }\n\n        globalResponse = response;\n        resolve(options.resolveBodyOnly ? response.body : response);\n      };\n\n      const onError = async error => {\n        if (promise.isCanceled) {\n          return;\n        }\n\n        if (!request.options) {\n          reject(error);\n          return;\n        }\n\n        request.off('response', onResponse);\n        let gotUnexpectedError = false;\n\n        const onUnexpectedError = error => {\n          gotUnexpectedError = true;\n          reject(error);\n        }; // If this is an HTTP error, then it can throw again with `ECONNRESET` or `Parse Error`\n\n\n        request.once('error', onUnexpectedError);\n        let backoff;\n        retryCount++;\n\n        try {\n          backoff = await options.retry.calculateDelay({\n            attemptCount: retryCount,\n            retryOptions: options.retry,\n            error,\n            computedValue: calculate_retry_delay_1.default({\n              attemptCount: retryCount,\n              retryOptions: options.retry,\n              error,\n              computedValue: 0\n            })\n          });\n        } catch (error_) {\n          // Don't emit the `response` event\n          request.destroy();\n          reject(new types_1.RequestError(error_.message, error, request));\n          return;\n        } // Another error was thrown already\n\n\n        if (gotUnexpectedError) {\n          return;\n        }\n\n        request.off('error', onUnexpectedError);\n\n        if (backoff) {\n          // Don't emit the `response` event\n          request.destroy();\n\n          const retry = async () => {\n            options.throwHttpErrors = throwHttpErrors;\n\n            try {\n              for (const hook of options.hooks.beforeRetry) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(options, error, retryCount);\n              }\n            } catch (error_) {\n              // Don't emit the `response` event\n              request.destroy();\n              reject(new types_1.RequestError(error_.message, error, request));\n              return;\n            }\n\n            makeRequest();\n          };\n\n          setTimeout(retry, backoff);\n          return;\n        } // The retry has not been made\n\n\n        retryCount--;\n\n        if (error instanceof types_1.HTTPError) {\n          // The error will be handled by the `response` event\n          void onResponse(request._response); // Reattach the error handler, because there may be a timeout later.\n\n          request.once('error', onError);\n          return;\n        } // Don't emit the `response` event\n\n\n        request.destroy();\n        reject(error);\n      };\n\n      request.once('response', onResponse);\n      request.once('error', onError);\n      proxy_events_1.default(request, emitter, proxiedRequestEvents);\n    };\n\n    makeRequest();\n  });\n\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      return core_1.parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n\n  promise.json = () => {\n    if (!globalRequest.writableFinished && options.headers.accept === undefined) {\n      options.headers.accept = 'application/json';\n    }\n\n    return shortcut('json');\n  };\n\n  promise.buffer = () => shortcut('buffer');\n\n  promise.text = () => shortcut('text');\n\n  return promise;\n}\n\nexports.default = asPromise;\n\n__exportStar(require(\"./types\"), exports);","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/got/dist/source/as-promise/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","exports","p","hasOwnProperty","value","PromisableRequest","events_1","require","PCancelable","calculate_retry_delay_1","types_1","core_1","default","proxy_events_1","get_buffer_1","proxiedRequestEvents","asPromise","options","retryCount","globalRequest","globalResponse","emitter","EventEmitter","promise","resolve","_reject","onCancel","makeRequest","throwHttpErrors","request","url","_noPipe","destroy","reject","error","hook","hooks","beforeError","error_","RequestError","message","onResponse","response","_a","aborted","isOk","statusCode","limitStatusCode","followRedirect","rawBody","_b","contentEncoding","headers","toLowerCase","isCompressed","includes","decompress","body","parseBody","responseType","parseJson","encoding","toString","index","afterResponse","entries","updatedOptions","typedOptions","normalizeArguments","retry","calculateDelay","resolveBodyOnly","slice","beforeRetry","catch","cancel","HTTPError","onError","isCanceled","off","gotUnexpectedError","onUnexpectedError","once","backoff","attemptCount","retryOptions","computedValue","setTimeout","_response","on","event","fn","shortcut","newPromise","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisableRequest = void 0;\nconst events_1 = require(\"events\");\nconst PCancelable = require(\"p-cancelable\");\nconst calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\nconst types_1 = require(\"./types\");\nconst core_1 = require(\"./core\");\nexports.PromisableRequest = core_1.default;\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(options) {\n    let retryCount = 0;\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, _reject, onCancel) => {\n        const makeRequest = () => {\n            // Support retries\n            // `options.throwHttpErrors` needs to be always true,\n            // so the HTTP errors are caught and the request is retried.\n            // The error is **eventually** thrown if the user value is true.\n            const { throwHttpErrors } = options;\n            if (!throwHttpErrors) {\n                options.throwHttpErrors = true;\n            }\n            // Note from @szmarczak: I think we should use `request.options` instead of the local options\n            const request = new core_1.default(options.url, options);\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            const reject = (error) => {\n                void (async () => {\n                    try {\n                        for (const hook of options.hooks.beforeError) {\n                            // eslint-disable-next-line no-await-in-loop\n                            error = await hook(error);\n                        }\n                    }\n                    catch (error_) {\n                        _reject(new types_1.RequestError(error_.message, error_, request));\n                        return;\n                    }\n                    _reject(error);\n                })();\n            };\n            globalRequest = request;\n            const onResponse = async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                const isOk = () => {\n                    const { statusCode } = response;\n                    const limitStatusCode = options.followRedirect ? 299 : 399;\n                    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;\n                };\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = core_1.parseBody(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (isOk()) {\n                            // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995\n                            reject(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995\n                    reject(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                if (throwHttpErrors && !isOk()) {\n                    reject(new types_1.HTTPError(response));\n                    return;\n                }\n                globalResponse = response;\n                resolve(options.resolveBodyOnly ? response.body : response);\n            };\n            const onError = async (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                if (!request.options) {\n                    reject(error);\n                    return;\n                }\n                request.off('response', onResponse);\n                let gotUnexpectedError = false;\n                const onUnexpectedError = (error) => {\n                    gotUnexpectedError = true;\n                    reject(error);\n                };\n                // If this is an HTTP error, then it can throw again with `ECONNRESET` or `Parse Error`\n                request.once('error', onUnexpectedError);\n                let backoff;\n                retryCount++;\n                try {\n                    backoff = await options.retry.calculateDelay({\n                        attemptCount: retryCount,\n                        retryOptions: options.retry,\n                        error,\n                        computedValue: calculate_retry_delay_1.default({\n                            attemptCount: retryCount,\n                            retryOptions: options.retry,\n                            error,\n                            computedValue: 0\n                        })\n                    });\n                }\n                catch (error_) {\n                    // Don't emit the `response` event\n                    request.destroy();\n                    reject(new types_1.RequestError(error_.message, error, request));\n                    return;\n                }\n                // Another error was thrown already\n                if (gotUnexpectedError) {\n                    return;\n                }\n                request.off('error', onUnexpectedError);\n                if (backoff) {\n                    // Don't emit the `response` event\n                    request.destroy();\n                    const retry = async () => {\n                        options.throwHttpErrors = throwHttpErrors;\n                        try {\n                            for (const hook of options.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(options, error, retryCount);\n                            }\n                        }\n                        catch (error_) {\n                            // Don't emit the `response` event\n                            request.destroy();\n                            reject(new types_1.RequestError(error_.message, error, request));\n                            return;\n                        }\n                        makeRequest();\n                    };\n                    setTimeout(retry, backoff);\n                    return;\n                }\n                // The retry has not been made\n                retryCount--;\n                if (error instanceof types_1.HTTPError) {\n                    // The error will be handled by the `response` event\n                    void onResponse(request._response);\n                    // Reattach the error handler, because there may be a timeout later.\n                    request.once('error', onError);\n                    return;\n                }\n                // Don't emit the `response` event\n                request.destroy();\n                reject(error);\n            };\n            request.once('response', onResponse);\n            request.once('error', onError);\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest();\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            return core_1.parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (!globalRequest.writableFinished && options.headers.accept === undefined) {\n            options.headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n__exportStar(require(\"./types\"), exports);\n"]},"metadata":{},"sourceType":"script"}
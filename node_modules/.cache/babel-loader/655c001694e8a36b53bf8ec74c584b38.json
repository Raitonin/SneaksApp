{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBody = exports.knownBodyTypes = void 0;\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst types_1 = require(\"./types\");\n\nconst core_1 = require(\"../core\");\n\nif (!core_1.knownHookEvents.includes('beforeRetry')) {\n  core_1.knownHookEvents.push('beforeRetry', 'afterResponse');\n}\n\nexports.knownBodyTypes = ['json', 'buffer', 'text'];\n\nexports.parseBody = (response, responseType, parseJson, encoding) => {\n  const {\n    rawBody\n  } = response;\n\n  try {\n    if (responseType === 'text') {\n      return rawBody.toString(encoding);\n    }\n\n    if (responseType === 'json') {\n      return rawBody.length === 0 ? '' : parseJson(rawBody.toString());\n    }\n\n    if (responseType === 'buffer') {\n      return Buffer.from(rawBody);\n    }\n\n    throw new types_1.ParseError({\n      message: `Unknown body type '${responseType}'`,\n      name: 'Error'\n    }, response);\n  } catch (error) {\n    throw new types_1.ParseError(error, response);\n  }\n};\n\nclass PromisableRequest extends core_1.default {\n  static normalizeArguments(url, nonNormalizedOptions, defaults) {\n    const options = super.normalizeArguments(url, nonNormalizedOptions, defaults);\n\n    if (is_1.default.null_(options.encoding)) {\n      throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');\n    }\n\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType); // `options.responseType`\n\n    if (options.responseType === undefined) {\n      options.responseType = 'text';\n    } // `options.retry`\n\n\n    const {\n      retry\n    } = options;\n\n    if (defaults) {\n      options.retry = { ...defaults.retry\n      };\n    } else {\n      options.retry = {\n        calculateDelay: retryObject => retryObject.computedValue,\n        limit: 0,\n        methods: [],\n        statusCodes: [],\n        errorCodes: [],\n        maxRetryAfter: undefined\n      };\n    }\n\n    if (is_1.default.object(retry)) {\n      options.retry = { ...options.retry,\n        ...retry\n      };\n      options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];\n      options.retry.statusCodes = [...new Set(options.retry.statusCodes)];\n      options.retry.errorCodes = [...new Set(options.retry.errorCodes)];\n    } else if (is_1.default.number(retry)) {\n      options.retry.limit = retry;\n    }\n\n    if (is_1.default.undefined(options.retry.maxRetryAfter)) {\n      options.retry.maxRetryAfter = Math.min( // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.\n      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n      ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));\n    } // `options.pagination`\n\n\n    if (is_1.default.object(options.pagination)) {\n      if (defaults) {\n        options.pagination = { ...defaults.pagination,\n          ...options.pagination\n        };\n      }\n\n      const {\n        pagination\n      } = options;\n\n      if (!is_1.default.function_(pagination.transform)) {\n        throw new Error('`options.pagination.transform` must be implemented');\n      }\n\n      if (!is_1.default.function_(pagination.shouldContinue)) {\n        throw new Error('`options.pagination.shouldContinue` must be implemented');\n      }\n\n      if (!is_1.default.function_(pagination.filter)) {\n        throw new TypeError('`options.pagination.filter` must be implemented');\n      }\n\n      if (!is_1.default.function_(pagination.paginate)) {\n        throw new Error('`options.pagination.paginate` must be implemented');\n      }\n    } // JSON mode\n\n\n    if (options.responseType === 'json' && options.headers.accept === undefined) {\n      options.headers.accept = 'application/json';\n    }\n\n    return options;\n  }\n\n  static mergeOptions(...sources) {\n    let mergedOptions;\n\n    for (const source of sources) {\n      mergedOptions = PromisableRequest.normalizeArguments(undefined, source, mergedOptions);\n    }\n\n    return mergedOptions;\n  }\n\n  _beforeError(error) {\n    if (this.destroyed) {\n      return;\n    }\n\n    if (!(error instanceof core_1.RequestError)) {\n      error = new core_1.RequestError(error.message, error, this);\n    } // Let the promise decide whether to abort or not\n    // It is also responsible for the `beforeError` hook\n\n\n    this.emit('error', error);\n  }\n\n}\n\nexports.default = PromisableRequest;","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/got/dist/source/as-promise/core.js"],"names":["Object","defineProperty","exports","value","parseBody","knownBodyTypes","is_1","require","types_1","core_1","knownHookEvents","includes","push","response","responseType","parseJson","encoding","rawBody","toString","length","Buffer","from","ParseError","message","name","error","PromisableRequest","default","normalizeArguments","url","nonNormalizedOptions","defaults","options","null_","TypeError","assert","any","string","undefined","boolean","resolveBodyOnly","methodRewriting","isStream","retry","calculateDelay","retryObject","computedValue","limit","methods","statusCodes","errorCodes","maxRetryAfter","object","Set","map","method","toUpperCase","number","Math","min","timeout","request","connect","filter","pagination","function_","transform","Error","shouldContinue","paginate","headers","accept","mergeOptions","sources","mergedOptions","source","_beforeError","destroyed","RequestError","emit"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseBody = exports.knownBodyTypes = void 0;\nconst is_1 = require(\"@sindresorhus/is\");\nconst types_1 = require(\"./types\");\nconst core_1 = require(\"../core\");\nif (!core_1.knownHookEvents.includes('beforeRetry')) {\n    core_1.knownHookEvents.push('beforeRetry', 'afterResponse');\n}\nexports.knownBodyTypes = ['json', 'buffer', 'text'];\nexports.parseBody = (response, responseType, parseJson, encoding) => {\n    const { rawBody } = response;\n    try {\n        if (responseType === 'text') {\n            return rawBody.toString(encoding);\n        }\n        if (responseType === 'json') {\n            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());\n        }\n        if (responseType === 'buffer') {\n            return Buffer.from(rawBody);\n        }\n        throw new types_1.ParseError({\n            message: `Unknown body type '${responseType}'`,\n            name: 'Error'\n        }, response);\n    }\n    catch (error) {\n        throw new types_1.ParseError(error, response);\n    }\n};\nclass PromisableRequest extends core_1.default {\n    static normalizeArguments(url, nonNormalizedOptions, defaults) {\n        const options = super.normalizeArguments(url, nonNormalizedOptions, defaults);\n        if (is_1.default.null_(options.encoding)) {\n            throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');\n        }\n        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);\n        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);\n        // `options.responseType`\n        if (options.responseType === undefined) {\n            options.responseType = 'text';\n        }\n        // `options.retry`\n        const { retry } = options;\n        if (defaults) {\n            options.retry = { ...defaults.retry };\n        }\n        else {\n            options.retry = {\n                calculateDelay: retryObject => retryObject.computedValue,\n                limit: 0,\n                methods: [],\n                statusCodes: [],\n                errorCodes: [],\n                maxRetryAfter: undefined\n            };\n        }\n        if (is_1.default.object(retry)) {\n            options.retry = {\n                ...options.retry,\n                ...retry\n            };\n            options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];\n            options.retry.statusCodes = [...new Set(options.retry.statusCodes)];\n            options.retry.errorCodes = [...new Set(options.retry.errorCodes)];\n        }\n        else if (is_1.default.number(retry)) {\n            options.retry.limit = retry;\n        }\n        if (is_1.default.undefined(options.retry.maxRetryAfter)) {\n            options.retry.maxRetryAfter = Math.min(\n            // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.\n            // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n            ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));\n        }\n        // `options.pagination`\n        if (is_1.default.object(options.pagination)) {\n            if (defaults) {\n                options.pagination = {\n                    ...defaults.pagination,\n                    ...options.pagination\n                };\n            }\n            const { pagination } = options;\n            if (!is_1.default.function_(pagination.transform)) {\n                throw new Error('`options.pagination.transform` must be implemented');\n            }\n            if (!is_1.default.function_(pagination.shouldContinue)) {\n                throw new Error('`options.pagination.shouldContinue` must be implemented');\n            }\n            if (!is_1.default.function_(pagination.filter)) {\n                throw new TypeError('`options.pagination.filter` must be implemented');\n            }\n            if (!is_1.default.function_(pagination.paginate)) {\n                throw new Error('`options.pagination.paginate` must be implemented');\n            }\n        }\n        // JSON mode\n        if (options.responseType === 'json' && options.headers.accept === undefined) {\n            options.headers.accept = 'application/json';\n        }\n        return options;\n    }\n    static mergeOptions(...sources) {\n        let mergedOptions;\n        for (const source of sources) {\n            mergedOptions = PromisableRequest.normalizeArguments(undefined, source, mergedOptions);\n        }\n        return mergedOptions;\n    }\n    _beforeError(error) {\n        if (this.destroyed) {\n            return;\n        }\n        if (!(error instanceof core_1.RequestError)) {\n            error = new core_1.RequestError(error.message, error, this);\n        }\n        // Let the promise decide whether to abort or not\n        // It is also responsible for the `beforeError` hook\n        this.emit('error', error);\n    }\n}\nexports.default = PromisableRequest;\n"]},"metadata":{},"sourceType":"script"}